You are a Lean 4 expert who is trying to help write a proof in Lean 4.

Problem Statement:
{problem}

{useful_theorems_section}

Informal Proof:
{informal_proof}

Instructions:

Use the informal proof to write a proof sketch for the problem in Lean 4 following these guidelines:
- Break complex reasoning into logical sub-goals using `have` statements.
- The subgoals should build up to prove the main theorem.
- Make sure to include all the steps and calculations from the given proof in the proof sketch.
- Each subgoal should ideally require applying just one key theorem or lemma, or a few tactic applications.
- Base subgoals around:
  - Useful theorems mentioned in the problem context
  - Standard library theorems (like arithmetic properties, set operations, etc.)
  - The supplied premises in the theorem statement
- Do NOT create subgoals identical to any of the given hypotheses
- Do NOT create subgoals that are more complex than the original problems. The subgoals should be SIMPLER than the given problem.
- Do NOT skip over any steps. Do NOT make any mathematical leaps.

**Subgoal Structure Requirements:**
- **Simplicity**: Each subgoal proof should be achievable with 1-3 basic tactics
- **Atomic reasoning**: Avoid combining multiple logical steps in one subgoal
- **Clear progression**: Show logical flow: `premises → intermediate steps → final result`
- **Theorem-focused**: Design each subgoal to directly apply a specific theorem when possible

NOTE: Only add sub-goals that simplify the proof of the main goal.

When writing Lean proofs, maintain consistent indentation levels.

Rules:
1. Same proof level = same indentation: All tactics at the same logical level must use identical indentation
2. Consistent characters: Use either tabs OR spaces consistently (don't mix)
3. Proper nesting: Indent sub-proofs one level deeper than their parent
4. Do NOT nest `have` statements in each other. Use distinct sub-goals as much as possible. Ensure all sub goals are named. Do NOT create anonymous have statements.
5. Do NOT include any imports or open statements in your code.
6. One line = One `have` subgoal. Do NOT split subgoals across different lines.
7. Use proper Lean 4 syntax and conventions. Ensure the proof sketch is enclosed in triple backticks ```lean```
8. Use `sorry` for all subgoal proofs - focus on structure, not implementation
9. **Do NOT use `sorry` for the main goal proof** - use your subgoals to prove it
10. NEVER use `sorry` IN the theorem statement itself
11. Ensure subgoals collectively provide everything needed for the main proof
12. Make the logical dependencies between subgoals explicit. Ensure that the subgoals are valid and provable in Lean 4.
13. Do NOT change anything in the original theorem statement.

-----------
Lean Hints:
TACTIC_HINTS="""
`rfl`: Use when there are definitionally equal terms
`exact h`: Use when hypothesis `h` matches the goal exactly  
`assumption`: Searches context for exact match to goal  
`intro x`: Use for `∀` or `→` in goal; names the new hypothesis  
`intros`: Introduces multiple variables/hypotheses at once  
`cases h`: Breaks down inductive hypothesis `h` into constructors  
`obtain ⟨x, y, h⟩ := h'`: Destructures existentials and conjunctions  
`rcases`: Recursive cases for nested inductive structures
`apply h`: Use when `h : P → Q` and goal is `Q`  
`refine h ?_ ?_`: Like apply but with explicit placeholders  
`rw [h]`: Rewrites using equality `h : a = b` left-to-right  
`rw [← h]`: Rewrites right-to-left  
`simp`: Simplifies using simp lemmas; use `simp only [...]` for control  
`simp_all`: Simplifies goal and all hypotheses  
`nth_rw n [h]`: Rewrites only the nth occurrence
`constructor`: Splits conjunctive goals or applies inductive constructors  
`left`/`right`: Choose side of disjunction  
`split`: Splits iff into both directions or conjunctions  
`by_contra h`: Proof by contradiction; adds `¬goal` as `h`  
`push_neg`: Pushes negation inward through quantifiers/connectives
`ring`: Solves polynomial ring equations  
`linarith`: Linear arithmetic solver  
`norm_num`: Evaluates numeric expressions  
`positivity`: Proves positivity/nonnegativity goals  
`field_simp`: Simplifies field expressions (clears denominators)
`have h : P := proof`: Introduces intermediate result  
`suffices h : P by proof`: Reduces goal to proving `P`  
`show P`: Changes goal to definitionally equal `P`  
`calc`: Chain of equations/inequalities with justifications  
`conv => ...`: Enter conv mode for targeted rewriting
`induction x`: Structural induction on `x`  
`induction x using ind_principle`: Custom induction principle  
`induction' x with ...`: More flexible case naming  
`cases x`: Case split without induction hypothesis
`classical`: Enter classical mode locally  
`by_cases h : P`: Case split on decidability of `P`  
`use x`: Provide witness for existential goal  
`choose f hf using h`: Extract choice function from proof
`·`: Focus on next goal  
`focus`: Focus on first goal  
`all_goals`: Apply tactic to all goals  
`any_goals`: Apply tactic to any matching goal  
`swap`: Swap first two goals  
`omega`: Integer linear arithmetic  
`decide`: Decision procedure for decidable propositions  
`tauto`: Propositional tautology checker  
`simp_all only [eq_self_iff_true]`: Common finishing pattern  
`repeat`: Apply tactic repeatedly until failure
"""

GENERAL_HINTS="""
1. When dealing with inequalities, equalities and arithmetic operations like subtraction or division in `ℕ` (natural numbers), beware of truncation. Use `ℝ`, `ℚ` or `ℤ` when possible for arithmetic operations. Avoid using `ℕ` unless required by the theorem statement.
2. Be ESPECIALLY careful about implicit types while defining numeric literals. AVOID patterns like `0 - 1` or `1 / 2` without specifying the types.
3. ALWAYS specify types when dealing with numeric values to avoid ambiguities and unexpected behavior.
4. Use `simp only [specific_lemmas]` rather than bare `simp` to avoid unpredictable simplifications.
5. Use `rw [← lemma]` for reverse direction. When `rw` fails, try `conv => rhs; rw [lemma]` to target specific subterms. nth_rw n [lemma] to rewrite only the nth occurrence.
6. When `ring` fails on ring expressions, try `ring_nf` first to normalize, or cast to a concrete ring like `ℝ` where the tactic works better.
7. Apply `norm_num` for concrete arithmetic calculations and `norm_cast` to simplify type coercions systematically.
8. Use `by_contra h` for proof by contradiction, which introduces the negation of the goal as hypothesis `h`.
9. If you get a `no goals to be solved` error, it means that the previous tactics already solved the goal, and you can remove the subsequent tactics.
10. When proving theorems, ALWAYS write the proof in tactic mode, starting the proof with `:= by`.
11. Do NOT use `begin`, `end` blocks in your proof. This is invalid in Lean 4.
"""

--------

IMPORTANT INSTRUCTION: Do NOT, under ANY circumstances, allow division and subtraction operations on natural number literals with UNDEFINED types, unless REQUIRED by the theorem statement. For example, do NOT allow literals like `1 / 3` or `2 / 5` or `1 - 3` ANYWHERE in ANY of the subgoals. ALWAYS specify the types. AVOID natural number arithmetic UNLESS NEEDED by the theorem statement. ALWAYS specify types when describing fractions. For example, ((2 : R) / 3) or ((2 : Q) / 3) instead of (2 / 3). Do this everywhere EXCEPT the given theorem statement. IMPORTANT INSTRUCTION: Do NOT, under ANY circumstances, allow division and subtraction operations on variables of type natural numbers (Nat or N), unless REQUIRED by the theorem statement. For example, do NOT allow expressions like (a-b) or (a/b) where a, b are of type N. ALWAYS cast the variables to a suitable type (Z, Q or R) when performing arithmetic operations. AVOID natural number arithmetic UNLESS NEEDED by the theorem statement.

STRICT OUTPUT CONSTRAINTS (must follow):
- Every `have` subgoal must be proved EXACTLY as `:= by sorry`. Do not use any other proof term or tactic inside `have`.
- The main proof (outside `have`) must NOT contain `sorry`, `admit`, or `by sorry`.
- Do not use `simp`, `ring`, `linarith`, `omega`, `aesop`, `nlinarith`, `norm_num`, `decide`, or any tactics inside `have` proofs. They may only be mentioned in comments, not executed.
- If you cannot meet these constraints, output an empty Lean code block.



