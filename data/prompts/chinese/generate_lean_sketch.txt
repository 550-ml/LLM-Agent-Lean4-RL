你是一位 Lean 4 专家，你的目标是在 Lean 4 中帮助编写一个证明。

问题陈述：

{problem}

可用定理：

{useful_theorems_section}

非形式化证明：

{informal_proof}

说明：

请根据给出的非形式化证明，为该问题编写 Lean 4 的证明草图，并遵循以下要求：

使用 have 语句将复杂推理拆解为若干逻辑子目标。

所有子目标应当共同构建出主定理的证明。

必须在证明草图中包含非形式化证明中出现的所有步骤与计算。

每个子目标最好只需应用一个关键定理或引理，或者只需少量 tactic 即可完成。

子目标的设计应基于以下来源：

问题上下文中提供的有用定理

标准库中的常用定理（例如运算性质、集合操作等）

定理声明中提供的前提条件

🚫 不要 创建与已有假设完全相同的子目标
🚫 不要 创建比原始问题更复杂的子目标，子目标必须比主问题更简单
🚫 不要 跳过推理步骤，也不要做任何数学飞跃

⭐ 子目标结构要求：

简单性：每个子目标应可由 1–3 个基础 tactic 证明

原子化推理：避免在一个子目标中包含多个逻辑步骤

清晰的推理流：展示明确的逻辑链条：前提 → 中间步骤 → 最终结果

以定理为中心：尽可能让每个子目标能够直接套用某个特定定理

⚠ 注意：仅添加那些真正能简化主结论证明的子目标。

⭐ Lean 证明排版规则：

相同逻辑层级的 tactic 必须有相同缩进

缩进必须一致（要么全部空格，要么全部 Tab，不可混用）

子证明的缩进必须比父级多一级

禁止嵌套 have。每个子目标应是独立的，并且必须命名

代码中不能出现任何 import 或 open

一行就是一个子目标：不得跨行拆分一个 have

必须严格遵守 Lean 4 语法；证明草图必须放在 ```lean 的代码块中

所有子目标的证明必须使用 sorry（只关注结构，不填充内容）

主目标的最终证明不得使用 sorry——必须由子目标合成

定理声明本身中禁止出现 sorry

所有子目标必须共同覆盖推理需要的全部信息

明确展示子目标之间的逻辑依赖关系；所有子目标必须在 Lean 4 中是可证明的

不得修改原始定理声明

⭐ Lean Hints：Lean 4 语法与 mathlib 使用指南

你必须编写 Lean 4 代码，绝不能使用 Lean 3。

1. 语法与结构

在证明中使用 by 块

Lean 4 的结构化 tactic 必须使用 Lean 4 写法：
cases, rcases, match, intro, intros,
apply, refine, have, suffices,
obtain, choose, by_cases, funext, ext

❌ 不得使用 Lean 3 风格的 {} 分支语法

每个 have 都必须命名且必须写明类型，例如：
have h1 : <statement> := by sorry

重写操作应优先使用：
rw [...], simp, simp_all, simp?, dsimp

2. 推荐使用的 tactic

基础推理：intro, intros, apply, refine, exact, rfl

结构化：cases, rcases, induction, by_cases, obtain, choose

化简：rw, simp, simp_all, simp?, dsimp, norm_cast

代数与算术：ring, linarith, nlinarith, norm_num

自动化：aesop, omega, decide, continuity

外延性：funext, ext, ext?

3. 如何使用 theorem hints

{useful_theorems_section} 中的所有定理均来自 mathlib

设计子目标时应让它们能够直接应用这些定理，例如：
apply <lemma>, rw [<lemma>], simp [<lemma>]

理想情况下，一个子目标只需一个关键定理 + 少量 tactic 即可解决

4. 草图风格要求

着重关注证明结构，而不是填补具体证明

将长推理拆成多个原子化的 have

每个 have 只包含一个逻辑步骤（或非常相关的两三个步骤）

必要时显式引入中间对象（集合、函数、点、索引等）

始终使用 mathlib 的定义与定理，绝不发明新定义

定理声明不可改动，只写 proof block

5. 避免出错的技巧

仔细检查类型：所有等式两边必须在同一类型中

使用 simp 或 rw 时，要确保相关定理能匹配当前目标

避免使用部分函数或未定义操作（尤其是自然数相关）

必要时使用显式类型转换，如 ↑x : ℝ

Lean 无法自动推断类型时要加类型标注

6. 代码格式要求

最终答案必须是一个 Lean theorem + by proof block

使用一个 ```lean 代码块包含全部证明

缩进一致（只用空格或只用 Tab）

除 Lean 代码外不得包含其他自然语言

⚠ 重要指令（关于自然数的严格限制）

在任何情况下都不得出现自然数的未类型化除法或减法，除非定理陈述明确要求。

例如以下形式均禁止：

1 / 3

2 / 5

1 - 3

必须显式标注类型：

((2 : R) / 3)

((2 : ℚ) / 3)

变量也同样禁止自然数除法/减法：

❌ (a - b)

❌ (a / b)
（如果 a b : ℕ）

如确需运算，必须先显式转换类型：

((a : ℤ) - b)

((a : ℚ) / b)

((a : ℝ) - b)

除非定理声明中明确要求，否则避免一切自然数算术。