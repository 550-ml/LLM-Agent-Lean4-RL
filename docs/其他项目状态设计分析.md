# 其他项目智能体状态设计分析

本文档分析工作区中其他三个项目的智能体状态设计思路。

## 1. Lean_copra 项目

### 1.1 状态设计架构

**核心状态类型：**
- `ProofState`: 证明状态，包含当前证明目标、上下文等信息
- `ProgressState`: 进度状态枚举，表示证明步骤的执行结果

**状态枚举值：**
```python
class ProgressState(Enum):
    STATE_CHANGED = 'STATE_CHANGED'      # 状态已改变（证明有进展）
    STATE_UNCHANGED = 'STATE_UNCHANGED'  # 状态未改变
    FAILED = 'FAILED'                    # 执行失败
    DONE = 'DONE'                        # 证明完成
```

### 1.2 状态流转机制

**状态转换流程：**
```
初始状态 (ProofState) 
  → Policy 选择 Action
  → Env.step(action) 
  → 返回 (state, modified_action, next_state, reward, done, info)
  → info.progress 指示 ProgressState
```

**关键代码位置：**
- `src/copra/agent/simple_proof_agent.py`: Agent 使用 `ProofState` 作为输入
- `src/copra/agent/dfs_tree_search_with_stack.py`: DFS 搜索中维护状态栈
- `src/copra/agent/handle_have_tactic.py`: 处理嵌套 `have` tactic 的状态追踪

### 1.3 状态管理特点

1. **环境驱动**: 状态由 `ProofEnv` 管理，Agent 通过 `env.step()` 获取新状态
2. **进度追踪**: 使用 `ProgressState` 枚举明确标识每一步的执行结果
3. **状态栈**: DFS 搜索中维护 `StateActionPair` 栈，支持回溯
4. **失败状态**: 区分不同类型的失败状态（`FailedCoqProofState`, `FailedLeanProofState` 等）

**示例代码：**
```python
# 从 simple_proof_agent.py
def _run_single_proof_step(self, env, next_state: ProofState, ...):
    action = self._policy(next_state)  # Policy 基于状态选择动作
    state, modified_action, next_state, reward, done, info = env.step(action)
    if info.progress == ProgressState.FAILED:
        # 处理失败情况
        max_proof_len = int(max_proof_len * (1 - reduction_percentage))
```

---

## 2. Lean4-LLM-Ai-Agent-Mooc 项目

### 2.1 状态设计架构

**无显式状态类**: 该项目采用函数式设计，状态通过函数参数和返回值传递。

**隐式状态管理：**
- 问题描述 (`problem_description`)
- 任务模板 (`task_lean_code`)
- 生成的代码和证明 (`generated_function_implementation`, `generated_proof`)
- 执行结果 (`execution_result`)

### 2.2 状态流转机制

**线性工作流：**
```
输入: problem_description, task_lean_code
  → Step 1: Reasoning Agent 分析 → reasoning_analysis
  → Step 2: LLM Agent 生成 → initial_solution
  → Step 3: 解析代码和证明 → code_part, proof_part
  → Step 4: 执行验证 → execution_result
  → Step 5: 如果失败，错误修正循环
  → 输出: {"code": ..., "proof": ...}
```

### 2.3 状态管理特点

1. **函数式设计**: 状态通过函数参数传递，无全局状态对象
2. **错误驱动**: 通过 `execution_result` 中的错误信息驱动修正循环
3. **简单直接**: 适合单次任务执行，不需要复杂的状态管理

**示例代码：**
```python
# 从 main.py
def main_workflow(problem_description: str, task_lean_code: str = "") -> LeanCode:
    reasoning_analysis = reasoning_agent.get_response([...])
    initial_solution = llm_agent.get_response([...])
    # 解析状态
    code_part = ...
    proof_part = ...
    # 执行验证
    execution_result = execute_lean_code(modified_task_code)
    if "error" in execution_result.lower():
        # 错误修正循环
        corrected_solution = llm_agent.get_response(correction_history)
```

---

## 3. draft_sketch_prove 项目

### 3.1 状态设计架构

**验证结果状态：**
- 使用字典结构存储验证结果
- 包含 `success`, `reason`, `num_steps`, `step_results` 等字段

**状态结构：**
```python
result = {
    'success': bool,           # 是否成功
    'reason': str,             # 失败原因
    'num_steps': int,          # 总步数
    'last_step': int,          # 最后执行的步数
    'step_results': List[Dict] # 每步的执行结果
}
```

### 3.2 状态流转机制

**验证流程：**
```
输入: formal (formal_statement + proof)
  → Checker 初始化 Isabelle 环境
  → 解析证明步骤 → steps
  → 逐步执行 → step_results
  → 检查 done 和 reward → success
  → 返回 result 字典
```

### 3.3 状态管理特点

1. **验证导向**: 状态主要用于记录验证过程，而非搜索过程
2. **步骤级追踪**: `step_results` 记录每一步的执行时间和输出
3. **外部环境**: 状态依赖 Isabelle 环境（PISA），通过端口通信

**示例代码：**
```python
# 从 checker.py
def check(self, formal):
    env = self._initialize()
    theory = Checker.minif2f_wrap_theorem(formal)
    steps = Checker.get_parsed(env, theory)
    
    step_results = []
    for i, step in enumerate(steps):
        obs, reward, done, metadata, error = self._run_step(step, i, tls_name, env)
        step_results.append(dict(
            index=i, 
            step=step, 
            output=self._parse_output(obs), 
            step_time=step_time
        ))
        if error is not None:
            break
    
    result = {
        'success': done and reward == 1.0,
        'reason': reason,
        'num_steps': len(steps),
        'last_step': len(step_results),
        'step_results': step_results
    }
    return result
```

---

## 4. 对比总结

### 4.1 状态设计模式对比

| 项目 | 状态类型 | 状态管理方式 | 状态流转 | 特点 |
|------|---------|------------|---------|------|
| **Lean_copra** | `ProofState` + `ProgressState` 枚举 | 环境驱动，Policy 基于状态决策 | 强化学习式：state → action → next_state | 最复杂，支持搜索和回溯 |
| **Lean4-LLM-Ai-Agent-Mooc** | 函数参数/返回值 | 函数式，无显式状态类 | 线性工作流：分析 → 生成 → 验证 → 修正 | 最简单，适合单次任务 |
| **draft_sketch_prove** | 字典结构 | 验证结果记录 | 验证流程：解析 → 执行 → 记录 | 中等复杂度，专注验证 |

### 4.2 设计理念差异

1. **Lean_copra**: 
   - **理念**: 强化学习式证明搜索
   - **状态**: 完整的证明状态（目标、上下文、历史）
   - **优势**: 支持复杂搜索策略（DFS、树搜索）
   - **适用**: 需要探索多个证明路径的场景

2. **Lean4-LLM-Ai-Agent-Mooc**:
   - **理念**: 简单直接的代码生成
   - **状态**: 隐式状态，通过函数参数传递
   - **优势**: 代码简洁，易于理解
   - **适用**: 单次任务，不需要复杂状态管理

3. **draft_sketch_prove**:
   - **理念**: 验证结果记录
   - **状态**: 验证过程的快照
   - **优势**: 详细记录验证过程，便于分析
   - **适用**: 批量验证和结果分析

### 4.3 可借鉴的设计点

1. **从 Lean_copra 学习**:
   - 使用枚举明确标识进度状态（`ProgressState`）
   - 环境管理状态，Agent 通过接口访问
   - 支持状态回溯（DFS 栈）

2. **从 Lean4-LLM-Ai-Agent-Mooc 学习**:
   - 简单场景下，函数式设计更清晰
   - 错误驱动的工作流设计

3. **从 draft_sketch_prove 学习**:
   - 详细记录执行过程（`step_results`）
   - 验证结果的标准化结构

---

## 5. 对当前项目的建议

基于 `LLM-Agent-Lean4-RL` 项目的 `AgentState` 设计，建议：

1. **保持当前设计**: `AgentState` dataclass 设计合理，包含了必要的状态信息
2. **可考虑添加**:
   - 进度状态枚举（类似 `ProgressState`）
   - 步骤历史记录（类似 `step_results`）
   - 状态验证方法

3. **状态流转建议**:
   - 明确状态转换规则
   - 记录状态变更历史
   - 支持状态回滚（如果需要）

